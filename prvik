section .data
    fib_length equ 48   ; Definirajte konstantu N ovdje

section .bss
    fib_numbers resq fib_length

section .text
    global _start

_start:
    ; Inicijalizacija prvih dva broja u nizu
    mov qword [fib_numbers], 0   ; F(0) = 0
    mov qword [fib_numbers + 8], 1   ; F(1) = 1

    ; Generiranje ostalih brojeva u nizu
    mov ecx, 2   ; Brojač petlje, počevši od 2
    mov rdi, fib_numbers   ; Početna adresa za pohranu sljedećeg broja

generate_fibonacci:
    mov rax, qword [rdi - 8]   ; Prethodni broj (F(i-1))
    add rax, qword [rdi - 16]   ; Prethodni prethodni broj (F(i-2))
    mov qword [rdi], rax   ; Spremi rezultat u memoriju (F(i))

    add rdi, 8   ; Povećaj adresu za idući broj
    inc ecx   ; Povećaj brojač petlje

    cmp ecx, fib_length   ; Provjeri jesmo li dosegli željenu duljinu
    jb generate_fibonacci   ; Ako nismo, ponovi petlju

    ; Ispisivanje generiranih brojeva
    mov ecx, fib_length   ; Brojač petlje za ispis
    mov rdi, fib_numbers   ; Početna adresa niza

print_fibonacci:
    mov rax, qword [rdi]
    call print_number   ; Poziv rutine za ispisivanje broja

    add rdi, 8   ; Povećaj adresu za idući broj
    loop print_fibonacci   ; Ponavljaj petlju dok ima brojeva za ispis

exit_program:
    mov eax, 1   ; Systen exit syscall number
    xor ebx, ebx   ; Exit status code (0)
    int 0x80   ; Poziv sustava za izlazak

print_number:
    ; Pretvorba broja u string
    push rax
    push rcx
    push rdx

    mov rsi, rsp   ; Adresa trenutnog vrha stoga

    xor rdx, rdx   ; Postavi nulu za ostatak
    mov rcx, 10   ; Bazna podloga za decimalnu pretvorbu

convert_digit:
    xor rax, rax   ; Postavi nulu za korištenje IDIVA
    div rcx   ; Podijeli broj s bazom, rezultat je u RAX, ostatak u RDX

    add dl, '0'   ; Pretvori ostatak u ASCII znamenku
    mov byte [rsi], dl   ; Spremi znamenku na stog
